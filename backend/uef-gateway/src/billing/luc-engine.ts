/**
 * LUC Engine (Local) — Locale Universal Calculator
 * Pure functions for usage tracking, quota management, and billing.
 *
 * PRONUNCIATION: "LUKE" (not L-U-C)
 *
 * This is the backend-local copy of the LUC engine. The canonical source
 * lives in aims-tools/luc/ (used by MCP/ACP tooling). This module inlines
 * the constants, types, and pure functions so the backend compiles within
 * its own rootDir without cross-package imports.
 *
 * Architecture foundation: Flip Secrets real estate calculator (aims-tools/luc/presets/real-estate-flip/).
 * LUC is a geographic-centered, multi-use-case calculator — it calculates tokens,
 * equations, adjustments, invoices, quotas, and everything the platform needs.
 */

import { v4 as uuidv4 } from 'uuid';

// ─────────────────────────────────────────────────────────────────────────────
// Service Key Registry (Stable, Never Change Once Published)
// Mirrors aims-tools/luc/luc.constants.ts
// ─────────────────────────────────────────────────────────────────────────────

export const SERVICE_KEYS = {
  LLM_TOKENS_IN: 'llm_tokens_in',
  LLM_TOKENS_OUT: 'llm_tokens_out',
  N8N_EXECUTIONS: 'n8n_executions',
  NODE_RUNTIME_SECONDS: 'node_runtime_seconds',
  SWARM_CYCLES: 'swarm_cycles',
  BRAVE_QUERIES: 'brave_queries',
  VOICE_CHARS: 'voice_chars',
  STT_MINUTES: 'stt_minutes',
  CONTAINER_HOURS: 'container_hours',
  STORAGE_GB_MONTH: 'storage_gb_month',
  BANDWIDTH_GB: 'bandwidth_gb',
  BOOMER_ANG_INVOCATIONS: 'boomer_ang_invocations',
  AGENT_EXECUTIONS: 'agent_executions',
  DEPLOY_OPERATIONS: 'deploy_operations',
  FORM_SUBMISSIONS: 'form_submissions',
  STEPPER_RUNS: 'stepper_runs',
  VIDEO_GENERATIONS: 'video_generations',
  IMAGE_GENERATIONS: 'image_generations',
  API_CALLS: 'api_calls',
} as const;

export type ServiceKey = (typeof SERVICE_KEYS)[keyof typeof SERVICE_KEYS];

// ─────────────────────────────────────────────────────────────────────────────
// Service Catalog
// ─────────────────────────────────────────────────────────────────────────────

export type ServiceCategory =
  | 'llm' | 'workflow' | 'voice' | 'infrastructure'
  | 'agent' | 'deployment' | 'api' | 'forms' | 'media';

export interface ServiceDefinition {
  key: ServiceKey;
  name: string;
  description: string;
  unit: string;
  unitPlural: string;
  category: ServiceCategory;
  defaultRate: number;
  meterType: 'count' | 'duration' | 'volume';
}

export const SERVICE_CATALOG: Record<ServiceKey, ServiceDefinition> = {
  [SERVICE_KEYS.LLM_TOKENS_IN]: { key: SERVICE_KEYS.LLM_TOKENS_IN, name: 'LLM Input Tokens', description: 'Tokens sent to language models', unit: 'token', unitPlural: 'tokens', category: 'llm', defaultRate: 0.001, meterType: 'count' },
  [SERVICE_KEYS.LLM_TOKENS_OUT]: { key: SERVICE_KEYS.LLM_TOKENS_OUT, name: 'LLM Output Tokens', description: 'Tokens generated by language models', unit: 'token', unitPlural: 'tokens', category: 'llm', defaultRate: 0.003, meterType: 'count' },
  [SERVICE_KEYS.N8N_EXECUTIONS]: { key: SERVICE_KEYS.N8N_EXECUTIONS, name: 'n8n Workflow Executions', description: 'Workflow runs on n8n automation platform', unit: 'execution', unitPlural: 'executions', category: 'workflow', defaultRate: 0.01, meterType: 'count' },
  [SERVICE_KEYS.NODE_RUNTIME_SECONDS]: { key: SERVICE_KEYS.NODE_RUNTIME_SECONDS, name: 'Node Runtime', description: 'Compute time for workflow nodes', unit: 'second', unitPlural: 'seconds', category: 'workflow', defaultRate: 0.0001, meterType: 'duration' },
  [SERVICE_KEYS.SWARM_CYCLES]: { key: SERVICE_KEYS.SWARM_CYCLES, name: 'Swarm Cycles', description: 'Agent swarm coordination cycles', unit: 'cycle', unitPlural: 'cycles', category: 'agent', defaultRate: 0.05, meterType: 'count' },
  [SERVICE_KEYS.BRAVE_QUERIES]: { key: SERVICE_KEYS.BRAVE_QUERIES, name: 'Brave Search Queries', description: 'Web search queries via Brave API', unit: 'query', unitPlural: 'queries', category: 'api', defaultRate: 0.005, meterType: 'count' },
  [SERVICE_KEYS.VOICE_CHARS]: { key: SERVICE_KEYS.VOICE_CHARS, name: 'Voice Characters', description: 'Characters synthesized to speech', unit: 'character', unitPlural: 'characters', category: 'voice', defaultRate: 0.00001, meterType: 'count' },
  [SERVICE_KEYS.STT_MINUTES]: { key: SERVICE_KEYS.STT_MINUTES, name: 'Speech-to-Text Minutes', description: 'Audio transcription duration', unit: 'minute', unitPlural: 'minutes', category: 'voice', defaultRate: 0.006, meterType: 'duration' },
  [SERVICE_KEYS.CONTAINER_HOURS]: { key: SERVICE_KEYS.CONTAINER_HOURS, name: 'Container Hours', description: 'Container runtime hours', unit: 'hour', unitPlural: 'hours', category: 'infrastructure', defaultRate: 0.05, meterType: 'duration' },
  [SERVICE_KEYS.STORAGE_GB_MONTH]: { key: SERVICE_KEYS.STORAGE_GB_MONTH, name: 'Storage (GB/month)', description: 'Cloud storage allocation', unit: 'GB-month', unitPlural: 'GB-months', category: 'infrastructure', defaultRate: 0.02, meterType: 'volume' },
  [SERVICE_KEYS.BANDWIDTH_GB]: { key: SERVICE_KEYS.BANDWIDTH_GB, name: 'Bandwidth (GB)', description: 'Data transfer volume', unit: 'GB', unitPlural: 'GB', category: 'infrastructure', defaultRate: 0.08, meterType: 'volume' },
  [SERVICE_KEYS.BOOMER_ANG_INVOCATIONS]: { key: SERVICE_KEYS.BOOMER_ANG_INVOCATIONS, name: 'Boomer_Ang Invocations', description: 'Agent supervisor invocations', unit: 'invocation', unitPlural: 'invocations', category: 'agent', defaultRate: 0.02, meterType: 'count' },
  [SERVICE_KEYS.AGENT_EXECUTIONS]: { key: SERVICE_KEYS.AGENT_EXECUTIONS, name: 'Agent Executions', description: 'Individual agent task executions', unit: 'execution', unitPlural: 'executions', category: 'agent', defaultRate: 0.01, meterType: 'count' },
  [SERVICE_KEYS.DEPLOY_OPERATIONS]: { key: SERVICE_KEYS.DEPLOY_OPERATIONS, name: 'Deploy Operations', description: 'Deployment pipeline operations', unit: 'operation', unitPlural: 'operations', category: 'deployment', defaultRate: 0.1, meterType: 'count' },
  [SERVICE_KEYS.FORM_SUBMISSIONS]: { key: SERVICE_KEYS.FORM_SUBMISSIONS, name: 'Form Submissions', description: 'Paperform form submissions processed', unit: 'submission', unitPlural: 'submissions', category: 'forms', defaultRate: 0.01, meterType: 'count' },
  [SERVICE_KEYS.STEPPER_RUNS]: { key: SERVICE_KEYS.STEPPER_RUNS, name: 'Stepper Workflow Runs', description: 'Stepper automation workflow executions', unit: 'run', unitPlural: 'runs', category: 'forms', defaultRate: 0.05, meterType: 'count' },
  [SERVICE_KEYS.VIDEO_GENERATIONS]: { key: SERVICE_KEYS.VIDEO_GENERATIONS, name: 'Video Generations', description: 'AI video clip generations via fal.ai / HuggingFace', unit: 'clip', unitPlural: 'clips', category: 'media', defaultRate: 0.40, meterType: 'count' },
  [SERVICE_KEYS.IMAGE_GENERATIONS]: { key: SERVICE_KEYS.IMAGE_GENERATIONS, name: 'Image Generations', description: 'AI image generations via fal.ai / Recraft / FLUX', unit: 'image', unitPlural: 'images', category: 'media', defaultRate: 0.05, meterType: 'count' },
  [SERVICE_KEYS.API_CALLS]: { key: SERVICE_KEYS.API_CALLS, name: 'API Calls', description: 'Generic API call metering', unit: 'call', unitPlural: 'calls', category: 'api', defaultRate: 0.001, meterType: 'count' },
};

// ─────────────────────────────────────────────────────────────────────────────
// Plan Definitions
// ─────────────────────────────────────────────────────────────────────────────

export const PLAN_IDS = {
  P2P: 'p2p',
  COFFEE: 'coffee',
  DATA_ENTRY: 'data_entry',
  PRO: 'pro',
  ENTERPRISE: 'enterprise',
} as const;

export type PlanId = (typeof PLAN_IDS)[keyof typeof PLAN_IDS];

export const PLAN_MULTIPLIERS: Record<PlanId, number> = {
  [PLAN_IDS.P2P]: 1,
  [PLAN_IDS.COFFEE]: 5,
  [PLAN_IDS.DATA_ENTRY]: 25,
  [PLAN_IDS.PRO]: 100,
  [PLAN_IDS.ENTERPRISE]: 1000,
};

// ─────────────────────────────────────────────────────────────────────────────
// Overage Policies
// ─────────────────────────────────────────────────────────────────────────────

export const OVERAGE_POLICIES = {
  BLOCK: 'block',
  ALLOW_OVERAGE: 'allow_overage',
  SOFT_LIMIT: 'soft_limit',
} as const;

export type OveragePolicy = (typeof OVERAGE_POLICIES)[keyof typeof OVERAGE_POLICIES];

// ─────────────────────────────────────────────────────────────────────────────
// Default Configuration
// ─────────────────────────────────────────────────────────────────────────────

export const LUC_DEFAULTS = {
  SOFT_WARN_THRESHOLD: 0.8,
  HARD_WARN_THRESHOLD: 0.95,
  OVERAGE_BUFFER: 0.1,
  BILLING_CYCLE_DAYS: 30,
} as const;

// ─────────────────────────────────────────────────────────────────────────────
// Types (TypeScript interfaces — mirrors Zod schemas in aims-tools/luc/)
// ─────────────────────────────────────────────────────────────────────────────

export interface Quota {
  serviceKey: ServiceKey;
  limit: number;
  used: number;
  reserved: number;
  overage: number;
}

export type QuotasMap = Partial<Record<ServiceKey, Quota>>;

export interface LucAccount {
  id: string;
  workspaceId: string;
  planId: PlanId;
  status: 'active' | 'suspended' | 'trial' | 'overdue';
  quotas: QuotasMap;
  overagePolicy: OveragePolicy;
  periodStart: string;
  periodEnd: string;
  createdAt: string;
  updatedAt: string;
}

export interface UsageEvent {
  id: string;
  workspaceId: string;
  userId?: string;
  serviceKey: ServiceKey;
  units: number;
  cost: number;
  requestId?: string;
  metadata?: Record<string, any>;
  timestamp: string;
  eventType: 'usage' | 'credit' | 'adjustment';
}

export interface CanExecuteResponse {
  canExecute: boolean;
  reason?: string;
  quotaRemaining: number;
  quotaLimit: number;
  percentUsed: number;
  wouldExceed: boolean;
  overage: number;
  warning?: string;
  warningLevel: 'none' | 'soft' | 'hard' | 'exceeded' | 'blocked';
}

export interface EstimateItem {
  serviceKey: ServiceKey;
  units: number;
  cost: number;
  quotaRemaining: number;
  wouldExceed: boolean;
  warning?: string;
}

export interface EstimateResponse {
  items: EstimateItem[];
  totalCost: number;
  anyWouldExceed: boolean;
  warnings: string[];
}

export interface RecordUsageRequest {
  workspaceId: string;
  serviceKey: ServiceKey;
  units: number;
  userId?: string;
  requestId?: string;
  metadata?: Record<string, any>;
}

export interface RecordUsageResponse {
  success: boolean;
  eventId: string;
  quotaRemaining: number;
  quotaLimit: number;
  percentUsed: number;
  overage: number;
  warning?: string;
}

export interface CreditUsageRequest {
  workspaceId: string;
  serviceKey: ServiceKey;
  units: number;
  reason: string;
  userId?: string;
  originalEventId?: string;
}

export interface CreditUsageResponse {
  success: boolean;
  eventId: string;
  quotaRemaining: number;
  credited: number;
}

export interface QuotaSummaryItem {
  serviceKey: ServiceKey;
  serviceName: string;
  limit: number;
  used: number;
  reserved: number;
  available: number;
  percentUsed: number;
  warningLevel: 'none' | 'soft' | 'hard' | 'exceeded';
  overage: number;
  estimatedCost: number;
}

export interface SummaryResponse {
  workspaceId: string;
  planId: PlanId;
  status: 'active' | 'suspended' | 'trial' | 'overdue';
  periodStart: string;
  periodEnd: string;
  daysRemaining: number;
  overallPercentUsed: number;
  overallWarningLevel: 'none' | 'soft' | 'hard' | 'exceeded';
  totalEstimatedCost: number;
  quotas: QuotaSummaryItem[];
  breakdown?: Record<string, { date: string; units: number; cost: number }[]>;
}

export interface LucState {
  overallPercent: number;
  warningLevel: 'none' | 'soft' | 'hard' | 'exceeded';
  activeBoomerAngs: number;
  boomerAngNames?: string[];
  projectedOverage: number;
  daysRemaining: number;
  topServices: { serviceKey: ServiceKey; name: string; percentUsed: number }[];
}

// ─────────────────────────────────────────────────────────────────────────────
// Quota Calculation Functions
// ─────────────────────────────────────────────────────────────────────────────

export function calculatePercentUsed(quota: Quota): number {
  if (quota.limit <= 0) return 0;
  return Math.min(100, Math.round((quota.used / quota.limit) * 100));
}

export function calculateRemaining(quota: Quota): number {
  if (quota.limit <= 0) return 0;
  return Math.max(0, quota.limit - quota.used - quota.reserved);
}

export function calculateOverage(quota: Quota): number {
  if (quota.limit <= 0) return 0;
  return Math.max(0, quota.used - quota.limit);
}

export function determineWarningLevel(
  percentUsed: number,
  softThreshold = LUC_DEFAULTS.SOFT_WARN_THRESHOLD,
  hardThreshold = LUC_DEFAULTS.HARD_WARN_THRESHOLD,
): 'none' | 'soft' | 'hard' | 'exceeded' {
  if (percentUsed >= 100) return 'exceeded';
  if (percentUsed >= hardThreshold * 100) return 'hard';
  if (percentUsed >= softThreshold * 100) return 'soft';
  return 'none';
}

export function generateWarningMessage(
  serviceKey: ServiceKey,
  percentUsed: number,
  level: 'none' | 'soft' | 'hard' | 'exceeded',
): string | undefined {
  const service = SERVICE_CATALOG[serviceKey];
  if (!service) return undefined;

  switch (level) {
    case 'soft':
      return `${service.name}: ${percentUsed}% of quota used`;
    case 'hard':
      return `${service.name}: ${percentUsed}% of quota used - approaching limit`;
    case 'exceeded':
      return `${service.name}: Quota exceeded (${percentUsed}%)`;
    default:
      return undefined;
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// Core Engine Functions
// ─────────────────────────────────────────────────────────────────────────────

export function canExecute(
  account: LucAccount,
  serviceKey: ServiceKey,
  units: number,
  overageBuffer = LUC_DEFAULTS.OVERAGE_BUFFER,
): CanExecuteResponse {
  const quota = account.quotas[serviceKey];

  if (!quota) {
    return {
      canExecute: false,
      reason: `Service ${serviceKey} not available in plan`,
      quotaRemaining: 0,
      quotaLimit: 0,
      percentUsed: 0,
      wouldExceed: true,
      overage: 0,
      warning: `Service ${serviceKey} is not included in your plan`,
      warningLevel: 'blocked',
    };
  }

  // P2P / metered — no included allocation, always allow, bill per use
  if (quota.limit <= 0) {
    return {
      canExecute: true,
      quotaRemaining: 0,
      quotaLimit: 0,
      percentUsed: 0,
      wouldExceed: false,
      overage: units,
      warningLevel: 'none',
    };
  }

  const wouldUse = quota.used + quota.reserved + units;
  const percentAfter = Math.round((wouldUse / quota.limit) * 100);
  const remaining = calculateRemaining(quota);
  const overage = Math.max(0, wouldUse - quota.limit);
  const warningLevel = determineWarningLevel(percentAfter);

  const maxAllowed = quota.limit * (1 + overageBuffer);
  let canDoIt = true;
  let reason: string | undefined;

  switch (account.overagePolicy) {
    case OVERAGE_POLICIES.BLOCK:
      if (wouldUse > quota.limit) {
        canDoIt = false;
        reason = 'Quota exceeded - operation blocked';
      }
      break;
    case OVERAGE_POLICIES.ALLOW_OVERAGE:
      if (wouldUse > maxAllowed) {
        canDoIt = false;
        reason = 'Overage limit exceeded - upgrade required';
      }
      break;
    case OVERAGE_POLICIES.SOFT_LIMIT:
      // Always allow for enterprise
      break;
  }

  if (account.status === 'suspended') {
    canDoIt = false;
    reason = 'Account suspended';
  }

  const warning = generateWarningMessage(serviceKey, percentAfter, warningLevel);

  return {
    canExecute: canDoIt,
    reason,
    quotaRemaining: remaining,
    quotaLimit: quota.limit,
    percentUsed: percentAfter,
    wouldExceed: wouldUse > quota.limit,
    overage,
    warning,
    warningLevel: canDoIt ? warningLevel : 'blocked',
  };
}

export function estimate(
  account: LucAccount,
  request: { services: { serviceKey: ServiceKey; units: number }[] },
): EstimateResponse {
  const items: EstimateItem[] = request.services.map((svc) => {
    const quota = account.quotas[svc.serviceKey];
    const service = SERVICE_CATALOG[svc.serviceKey];
    const rate = service?.defaultRate || 0;
    const cost = svc.units * rate;

    if (!quota) {
      return {
        serviceKey: svc.serviceKey,
        units: svc.units,
        cost,
        quotaRemaining: 0,
        wouldExceed: true,
        warning: `Service ${svc.serviceKey} not available`,
      };
    }

    const remaining = calculateRemaining(quota);
    const wouldExceed = quota.limit > 0 && svc.units > remaining;
    const percentAfter = quota.limit <= 0
      ? 0
      : Math.round(((quota.used + svc.units) / quota.limit) * 100);
    const warningLevel = determineWarningLevel(percentAfter);
    const warning = generateWarningMessage(svc.serviceKey, percentAfter, warningLevel);

    return { serviceKey: svc.serviceKey, units: svc.units, cost, quotaRemaining: remaining, wouldExceed, warning };
  });

  const totalCost = items.reduce((sum, item) => sum + item.cost, 0);
  const anyWouldExceed = items.some((item) => item.wouldExceed);
  const warnings = items.filter((item) => item.warning).map((item) => item.warning!);

  return { items, totalCost, anyWouldExceed, warnings };
}

export function recordUsage(
  account: LucAccount,
  request: RecordUsageRequest,
): { updatedQuota: Quota; event: UsageEvent; response: RecordUsageResponse } {
  const svcKey = request.serviceKey;
  const quota = account.quotas[svcKey];
  const service = SERVICE_CATALOG[svcKey];
  const rate = service?.defaultRate || 0;
  const cost = request.units * rate;

  if (!quota) {
    throw new Error(`Service ${svcKey} not available in account`);
  }

  const updatedQuota: Quota = {
    ...quota,
    used: quota.used + request.units,
    overage: Math.max(0, quota.used + request.units - quota.limit),
  };

  const event: UsageEvent = {
    id: uuidv4(),
    workspaceId: request.workspaceId,
    userId: request.userId,
    serviceKey: svcKey,
    units: request.units,
    cost,
    requestId: request.requestId,
    metadata: request.metadata,
    timestamp: new Date().toISOString(),
    eventType: 'usage',
  };

  const percentUsed = calculatePercentUsed(updatedQuota);
  const warningLevel = determineWarningLevel(percentUsed);
  const warning = generateWarningMessage(svcKey, percentUsed, warningLevel);

  const response: RecordUsageResponse = {
    success: true,
    eventId: event.id,
    quotaRemaining: calculateRemaining(updatedQuota),
    quotaLimit: updatedQuota.limit,
    percentUsed,
    overage: updatedQuota.overage,
    warning,
  };

  return { updatedQuota, event, response };
}

export function creditUsage(
  account: LucAccount,
  request: CreditUsageRequest,
): { updatedQuota: Quota; event: UsageEvent; response: CreditUsageResponse } {
  const svcKey = request.serviceKey;
  const quota = account.quotas[svcKey];

  if (!quota) {
    throw new Error(`Service ${svcKey} not available in account`);
  }

  const newUsed = Math.max(0, quota.used - request.units);

  const updatedQuota: Quota = {
    ...quota,
    used: newUsed,
    overage: Math.max(0, newUsed - quota.limit),
  };

  const event: UsageEvent = {
    id: uuidv4(),
    workspaceId: request.workspaceId,
    userId: request.userId,
    serviceKey: svcKey,
    units: request.units,
    cost: 0,
    metadata: { reason: request.reason, originalEventId: request.originalEventId },
    timestamp: new Date().toISOString(),
    eventType: 'credit',
  };

  const response: CreditUsageResponse = {
    success: true,
    eventId: event.id,
    quotaRemaining: calculateRemaining(updatedQuota),
    credited: request.units,
  };

  return { updatedQuota, event, response };
}

export function generateSummary(account: LucAccount): SummaryResponse {
  const now = new Date();
  const periodEnd = new Date(account.periodEnd);
  const daysRemaining = Math.max(
    0,
    Math.ceil((periodEnd.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)),
  );

  const quotas: QuotaSummaryItem[] = Object.entries(account.quotas).map(([key, rawQuota]) => {
    const serviceKey = key as ServiceKey;
    const quota = rawQuota as Quota;
    const service = SERVICE_CATALOG[serviceKey];
    const percentUsed = calculatePercentUsed(quota);
    const warningLevel = determineWarningLevel(percentUsed);
    const overage = calculateOverage(quota);
    const estimatedCost = quota.used * (service?.defaultRate || 0);

    return {
      serviceKey,
      serviceName: service?.name || serviceKey,
      limit: quota.limit,
      used: quota.used,
      reserved: quota.reserved,
      available: calculateRemaining(quota),
      percentUsed,
      warningLevel,
      overage,
      estimatedCost,
    };
  });

  const totalLimit = quotas.reduce((sum, q) => (q.limit <= 0 ? sum : sum + q.limit), 0);
  const totalUsed = quotas.reduce((sum, q) => sum + q.used, 0);
  const overallPercentUsed = totalLimit > 0 ? Math.round((totalUsed / totalLimit) * 100) : 0;
  const overallWarningLevel = determineWarningLevel(overallPercentUsed);
  const totalEstimatedCost = quotas.reduce((sum, q) => sum + q.estimatedCost, 0);

  return {
    workspaceId: account.workspaceId,
    planId: account.planId,
    status: account.status,
    periodStart: account.periodStart,
    periodEnd: account.periodEnd,
    daysRemaining,
    overallPercentUsed,
    overallWarningLevel,
    totalEstimatedCost,
    quotas,
  };
}

export function generateLucState(
  account: LucAccount,
  activeBoomerAngs: string[] = [],
  showNames = false,
): LucState {
  const summary = generateSummary(account);

  const topServices = summary.quotas
    .filter((q) => q.limit > 0)
    .sort((a, b) => b.percentUsed - a.percentUsed)
    .slice(0, 3)
    .map((q) => ({
      serviceKey: q.serviceKey,
      name: q.serviceName,
      percentUsed: q.percentUsed,
    }));

  return {
    overallPercent: summary.overallPercentUsed,
    warningLevel: summary.overallWarningLevel,
    activeBoomerAngs: activeBoomerAngs.length,
    boomerAngNames: showNames ? activeBoomerAngs : undefined,
    projectedOverage: summary.quotas.reduce((sum, q) => sum + q.overage, 0),
    daysRemaining: summary.daysRemaining,
    topServices,
  };
}

// ─────────────────────────────────────────────────────────────────────────────
// Utility Functions
// ─────────────────────────────────────────────────────────────────────────────

export function initializeQuotas(planLimits: Record<string, number>): QuotasMap {
  const quotas: QuotasMap = {};
  for (const [key, limit] of Object.entries(planLimits)) {
    quotas[key as ServiceKey] = {
      serviceKey: key as ServiceKey,
      limit,
      used: 0,
      reserved: 0,
      overage: 0,
    };
  }
  return quotas;
}

export function isValidServiceKey(key: string): key is ServiceKey {
  return Object.values(SERVICE_KEYS).includes(key as ServiceKey);
}
